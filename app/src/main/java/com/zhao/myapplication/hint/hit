OOM 即内存溢出，应用需要分配的内存超过了系统对应用内存的阈值
内存泄露 本质上是因为生命周期较长的对象去引用生命周期较短的对象，导致生命周期短的对象无法呗GC即使回收掉
1.handler 引起
2.bitmap没有调用recycle
3.资源型对象应当使用完及时关闭
4.注册没有取消
5.
内存抖动 主要是由于频繁的创建和销毁对象导致 -> 频繁调用gc
1.比如再onDraw 里面创建对象
2.大量的字符串拼接
8.0之前内存抖动会产生内存碎片，过多之后，新建大对象，会出现oom
程序卡顿
ANR 是指应用程序未响应
事件分发超时dispatchTimeout
避免再主线程中进行耗时操作
避免死锁，死循环的情况

View的绘制流程
从activity的setContentView 开始
1.setContentView() -> getWindow() = PhoneWindow
2.DecorView ->Activity中根View extends FrameLayout
3.根据主题加载 加载不同的 layoutResource
4.加载自己写的xml
View的分发机制
#这个可以看 https://www.bilibili.com/video/BV1RZ4y1T7q1?p=10&vd_source=c667e6b45694b3b681071057e680db10
#直接教你手写Android事件分发，自己写一次印象深刻
dispatchTouchEvent -> 事件分发
dispatchTransformedTouchEvent -> 处理分发
onInterceptTouchEvent -> 事件拦截
onTouchEvent -> 事件处理

从Activity的开始
1.Activity 的 分发
2.没有拦截  交给 ViewGroup
3.没有拦截处理 交给下面ViewGroup 或者View
4.View 也没有处理 原路返回
一个U形状得传递图
DOWN MOVE UP 比较重要吧 ,还有点击区域也要考虑到  大于left 小于 right 大于top 小于 bottom 才会接受到事件 有资格进行处理  TouchTarget View[] 额类似 Handler Message的方式吧有点  链表回收池
TouchTarget 为当前View可以理解为缓存什么的

Handler
Message ->消息，数据单元
Message Queue ->消息队列 先进先出
Handler -> 将Message添加到消息队列，以及对消息队列的Message进行处理
Looper -> 循环器，循环取出消息队列的消息，并交给相应的Handler

handler.sendMessage
handler.handleMessage

Thread 线程
1.继承Thread，重写run
2.实现Runnable 实现run
3.实现Callable 重写run

线程同步
1.ReentrantLock 重入锁 表示能够支持一个线程重复加锁  通常加到try之前 finally之后解锁
2.await 进入阻塞状态，知道另一个线程调用同一个条件的signalAll方法
3.synchronized
4.volatile 当一个变量被volatile修饰之后就具备两个含义1.当线程修改了变量的值，变量的新值对其他线程是立即可见的2.禁止使用里那个重排序：编译重排序，运行重排序

ListView和RecyclerView的区别
ListView：只能垂直滑动。有几个默认的Adapter。拥有子item的监听函数。不强制使用ViewHolder。两级缓存
RecyclerView：支持水平，垂直，瀑布流。Adapter需要自己实现。需要自己去实现接口。强制使用ViewHolder。四级缓存
ListView两级缓存
1.mActiveViews用户屏幕内ItemView的快速服用
2.mScrapViews用户缓存离开屏幕的ItemView
RecyclerView的四级缓存
1.mChangeScrap与mAttachedScrap用于屏幕内ItemView的快速移动
2.mChangeViews 默认上限为2，及缓存屏幕外的2个ItemView
3.mViewCacheExtension 用户自定义
4.RecyclerviewPool的上限为5
缓存对象的不同
Recyclerview缓存的是ViewHolder，ListView缓存的是View

ListView相对于RecyclerView的优化
1.实现了HeaderView和FooterView的方法
2.分割线可以直接设置
3.实现了点击方法
Recyclerview相对于LisView的优点
1.封装了ViewHolder，效率更高
2.可以添加增删Item动画，侧滑功能
3.支持局部刷新
4.更加解耦

滑动冲突



activity启动模式
standard
singleTop   生命周期 onCreate->onStart->onResume->onPause->onResume
singleTask
singleInstance

HashMap
HashMap本质上是一个散列表
三个问题：1.散列函数，2.哈希冲突，3.扩容方案
数据结构  多线程问题
HashMap属于Map集合体系的一部分，同时继承了Serializable可以被序列化，继承cloneable可以被复制
1.哈希函数的目标是计算key在数组中的下标，判断哈希函数的标准是：散列是否均匀，计算是否简单
  通过高16位与低16位进行异或运算来让高位参与散列，提高性能
  HashMap数组的长度位2的整数次幂来简化取模运算，提高性能
  HashMap通过控制初始化数组长度为2的正数次幂、扩容为原来2倍来控制数组长度一定为2的整数次幂
2.Hash冲突是指两个不同的key经过hash计算之后得到的数组下标是相同的
  HashMap采用的是链地址法，jdk1.8增加了红黑树优化
  出现冲突之后会在当前节点形成链表，当链表过长之后，会自动转化为红黑树，时间复杂度OlogN
    1.当链表的长度>=8且数组长度>=64,会转化为红黑树
    2.当链表长度>=8,但是数组长度<64,会优先进行扩容
    3.当红黑树节点<=6 会自动转化为链表


