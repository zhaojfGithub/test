面对对象与面对过程
1.对于C语言来说，是完全面向过程的
2.对于C++来说，是半面对对象的
3.对于Java来说，是面对对象的
面向过程：简称PO,把事情分为几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行
面向对象：简称OO，面向对象会把事情抽象成对象的概念，先抽象对出对象，然后给对象赋一些属性和方法，让后让每个对象去执行自己的方法
面向对象优点：效率高，因为不需要实例化对象 缺点。耦合度高，扩展性差，不容易维护
面向对象的优化：耦合低，扩展性强，易维护，缺点 效率低  特性：封装，继承，多态

java八大基础数据类型
1byte = 8bit
整数型：byte short int long
浮点型：float double
布尔型：boolean
字符型：char
byte = 1byte = 8bit
short = 2byte
int = 4byte
long = 8byte
float = 4byte
double = 8byte
boolean = 1byte
char = 2byte

ConcurrentHashMap 线程安全  锁的是数组的节点

HashMap
HashMap本质上是一个散列表
三个问题：1.散列函数，2.哈希冲突，3.扩容方案
数据结构  多线程问题
HashMap属于Map集合体系的一部分，同时继承了Serializable可以被序列化，继承cloneable可以被复制
1.哈希函数的目标是计算key在数组中的下标，判断哈希函数的标准是：散列是否均匀，计算是否简单
  通过高16位与低16位进行异或运算来让高位参与散列，提高性能
  HashMap数组的长度位2的整数次幂来简化取模运算，提高性能
  HashMap通过控制初始化数组长度为2的正数次幂、扩容为原来2倍来控制数组长度一定为2的整数次幂
2.Hash冲突是指两个不同的key经过hash计算之后得到的数组下标是相同的
  HashMap采用的是链地址法，jdk1.8增加了红黑树优化
  出现冲突之后会在当前节点形成链表，当链表过长之后，会自动转化为红黑树，时间复杂度OlogN
    1.当链表的长度>=8且数组长度>=64,会转化为红黑树
    2.当链表长度>=8,但是数组长度<64,会优先进行扩容
    3.当红黑树节点<=6 会自动转化为链表

Kotlin 委托机制及其原理
类委托，属性委托，局部变量委托


Kotlin dataclass 与 class的区别
dataclass必须要有带参数的构造方法
dataclass不能被继承
都会生成get,set和构造方法
dataclass会额外生成copy方法，toString，equals，hashCode 方法

java的几种内部类
1.成员内部类  当某个类除了他的外部类。不会被其他类使用时应当使用成员内部类
2.静态内部类  在声明类的时候加上static关键字，他与外部类的属性，方法是并列关系
3.局部内部类  写在外部类的某个代码块或者方法块中，如果只在某个方法块中创建这个类的某些对象，则可以使用局部内部类
4.匿名内部类  在new的后面，额可以用来实现一个接口或者继承一个类

outputStream  向文件中写入一个字节
inputStream   向文件中读取一个字节

进程状态可以分为：创建、就绪、运行、阻塞、结束 与线程类似
进程之间的通信方式
1.管道/匿名管道：用于具有亲缘关系得父子之间或者兄弟进程之间的通信
2.有名管道：遵循先进先出，是以磁盘文件的方式存在，可以实现本机任意两个进程通讯
3.信号：信号主要用于通知接收进程某个事件已经发生
4.消息队列：消息队列是消息的链表，先进先出，消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。
5.信号量：信号量是一个计数器，用于多进程对共享数据的访问，意图在于进程之间的同步
6.共享内存：使多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新，比较常用
7.套接字：主要用于在客户端和服务器之间通过网络进行通信
线程之间的同步方式
1.互斥量：采用互斥对象机制，只有拥有互斥对象的线程还有访问公共资源的权限,Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2.信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
进程的调度算法
1.先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
2.短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
3.时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
4.多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，
仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。
5.优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
产生死锁的四个必要条件
1.互斥：当资源处于非共享模式，即一次只有一个进程可以使用，如果另一进程申请该资源，那么必须等待到该资源释放为止
2.占有并等待：一个进程至少应该占用一个资源，并等待另一资源，而该资源被其他线程占用
3.非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放
4.循环等待：有一组等待线程p0等待的资源被p1占有，p1等待的资源被p2占用，pn被p0占有
解决思索的主要办法
1.静态分配策略
指一个进程必须在执行前就获得他所需要的资源，缺点是严重降低了资源利用率
2.层次分配策略
层次分配策略破环了产生死锁的第四个条件(循环等待)
即所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源